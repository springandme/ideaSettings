<application>
  <component name="AppStorage">
    <histories>
      <item value="国家" />
      <item value="amount" />
      <item value=" Hostname the broker will advertise to producers and consumers. If not set, it uses the   # value for &quot;host.name&quot; if configured.  Otherwise, it will use the value returned from   # java.net.InetAddress.getCanonicalHostName()" />
      <item value="ERROR - Failed to collate messages by topic, partition due to: Failed to fetch topic metadata for topic: canal" />
      <item value="tries" />
      <item value="ERROR - Failed to send requests for topics canal with correlation ids in [0,8]" />
      <item value="retries" />
      <item value="I increased TM memory and this issue disappeared. Seems like off heap OOM." />
      <item value="As mentioned in the comments, the asker resolved this as follows:" />
      <item value="Though probably not directly related it is of course also wise to avoid using mixed versions." />
      <item value="I have a streaming job failed after running for 1day and 10 hours. One of the subtasks suddenly failed and crashed the whole job. Since I set up a restart_strategy, the job automatically restarted but crashed again with the same error. I found the Task Manager's log that the failed task was on, but it is not very helpful for me to debug this. Can anyone suggest a better way? Thank you." />
      <item value="延迟" />
      <item value="Externalized" />
      <item value="tracking" />
      <item value="分布式" />
      <item value="supplied" />
      <item value="The operator name Window(TumblingEventTimeWindows(3000), EventTimeTrigger, ScalaReduceFunction, PassThroughWindowFunction) exceeded the 80 characters length limit and was truncated." />
      <item value="was supplied but isn't a known config." />
      <item value="重构" />
      <item value="Sorry, passwords do not match" />
      <item value="Interrupted" />
      <item value="Creates a new DataStream by applying the given function to every element and flattening * the results." />
      <item value="FastDateFormat is a fast and thread-safe version of" />
      <item value="处理" />
      <item value="qualifier" />
      <item value="Use {@link Connection#getAdmin()} to obtain an instance of {@link Admin} instead of constructing * an HBaseAdmin directly." />
      <item value="HBaseAdmin is no longer a client API" />
      <item value="The previous internal timestamp of the element, * or a negative value, if no timestamp has been assigned yet." />
      <item value="The element that the timestamp will be assigned to." />
      <item value="Assigns a timestamp to an element, in milliseconds since the Epoch. * * &lt;p&gt;The method is passed the previously assigned timestamp of the element. * That previous timestamp may have been assigned from a previous assigner, * by ingestion time. If the element did not carry a timestamp before, this value is * {@code Long.MIN_VALUE}." />
      <item value="periodic" />
      <item value="Periodic" />
      <item value="assign" />
      <item value="// 构建Message Message msg = new Message(); msg.setMessage(json); msg.setCount(1); msg.setTimeStamp(System.currentTimeMillis()); String msgJSON = JSON.toJSONString(msg); // 发送Message到Kafka kafkaTemplate.send(&quot;pyg&quot;, msgJSON); map.put(&quot;success&quot;, &quot;true&quot;);" />
      <item value="Compute the partition for the given record." />
      <item value="Atomically increments by one the current value." />
      <item value="An {@code int} value that may be updated atomically. See the * {@link java.util.concurrent.atomic} package specification for * description of the properties of atomic variables. An * {@code AtomicInteger} is used in applications such as atomically * incremented counters, and cannot be used as a replacement for an * {@link java.lang.Integer}. However, this class does extend * {@code Number} to allow uniform access by tools and utilities that * deal with numerically-based classes." />
      <item value="broker" />
      <item value="定时" />
      <item value="slide" />
      <item value="mutable" />
      <item value="A list of host/port pairs to use for establishing the initial connection to the Kafka cluster. The client will make use of all servers irrespective of which servers are specified here for bootstrapping&amp;mdash;this list only impacts the initial hosts used to discover the full set of servers. This list should be in the form &quot; + &quot;&lt;code&gt;host1:port1,host2:port2,...&lt;/code&gt;. Since these servers are just used for the initial connection to &quot; + &quot;discover the full cluster membership (which may change dynamically), this list need not contain the full set of &quot; + &quot;servers (you may want more than one, though, in case a server is down).&quot;;" />
      <item value="practice" />
      <item value="练习" />
      <item value="Additional context about the input record." />
      <item value="Writes the given value to the sink. This function is called for every record. * * &lt;p&gt;You have to override this method when implementing a {@code SinkFunction}, this is a * {@code default} method for backward compatibility with the old-style method only." />
      <item value="Interface for implementing user defined sink functionality." />
      <item value="intent" />
      <item value="Returns a pseudorandom, uniformly distributed int value between 0 * (inclusive) and the specified value (exclusive), drawn from this * random number generator's sequence." />
      <item value="随机" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="577" />
        <entry key="ENGLISH" value="578" />
        <entry key="ARABIC" value="1" />
        <entry key="FRENCH" value="3" />
        <entry key="LATIN" value="2" />
        <entry key="LITHUANIAN" value="1" />
        <entry key="LUXEMBOURGISH" value="1" />
        <entry key="JAPANESE" value="10" />
        <entry key="SWEDISH" value="1" />
        <entry key="WELSH" value="3" />
      </map>
    </option>
  </component>
  <component name="Settings">
    <option name="ignoreRegExp" value="" />
    <option name="phoneticFontFamily" value="Consolas" />
    <option name="primaryFontFamily" value="Consolas" />
  </component>
</application>